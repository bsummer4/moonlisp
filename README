# Moonlisp
This is a simple lisp implementation that uses tables and strings instead of
lists and symbols as it's core data structures. It compiles to Lua, Javascript
and Python.

## Semantics
Types: (t ::= bool func str num foreign table)
All functions are of the form t→t.
Tables are mutable and map from t→t.
All values are immutable besides tables and foreigns.

## Basic Syntax
Reserved characters:: ““”#<>[]{}()"← \t\r\n”
All-non-reserved characters can be used raw, in identifiers.
Syntax for atomic data structures:: #true #false str <str> 4.5
Quoted Strings:: "string" “string”
Keys in ‘key←val’ forms must be atomic data structures.
Syntactic forms:: (foo bar a←b)
Table literals:: {foo bar a←b}
Function calls:: [foo bar zaz a←b] (this passes {bar zaz a←b} to foo)

Primitive lisp forms:
	(λ name exp)
	(match exp (pattern exp) ...)
	(do exp ...)

Foreign function calls:
	#[require io]
	#[io.write("foreign code")]
	(#(io.write(%1)) "foreign function call")
	(def output #(io.write(%1)))
	(output "foreign function call")

Patterns are just data-literals mixed with symbols::
	(match {1 {2} 3} ({1 b c} {b c}))
		This yields: {{2} 3}

## Supported Operations
.        :: {table t} → t         -- Table lookup
!        :: {table t t} → t       -- Table mutation
apply    :: {func table} → t      -- Call function explicitly.
keys     :: {table} → table       -- Table keys
%        :: {table} → num         -- Array length
append   :: {table table} → table -- Array concatenation
read     :: string → t            -- Read data expression.
write    :: t → string            -- Write data expression.
+        :: {num num} → num
-        :: {num num} → num
*        :: {num num} → num
/        :: {num num} → num
%        :: {num num} → num
^        :: {num num} → num
=        :: {t t} → bool          -- Equality
~=       :: {num num} → bool
<=       :: {num num} → bool
>=       :: {num num} → bool
<        :: {num num} → bool
>        :: {num num} → bool
..       :: {str str} → str       -- Concatenation.
nil?     :: {t} → bool
bool?    :: {t} → bool
func?    :: {t} → bool
str?     :: {t} → bool
num?     :: {t} → bool
foreign? :: {t} → bool
table?   :: {t} → bool

## Example Code
(do
	(match {1 2 k←c} ({a b k←c} (do
		[write a b c])
	(match {1 2 k←3} (e (do
		[write e])))
	(match (λx (match x ({a b k←c} [write a b c])))
		(hello [hello 1 2 k←3]))
	(match {
		(λ pair pair)
		(λ pair (match pair ({car cdr} car)))
		(λ pair (match pair ({car cdr} car)))}
		({cons car cdr} [= [car [cons car cdr]]])))))

# Moonlisp
This is a simple lisp implementation that uses tables and strings instead of
lists and symbols as it's core data structures. It compiles to Lua, Javascript
and Python.

## Semantics
Types: (t ::= bool func str num foreign table)
All functions are of the form t→t.
Tables are mutable and map from t→t.
All values are immutable besides tables and foreigns.

## Basic Syntax
Reserved characters:: ““”#<>[]{}()":.$→ \t\r\n”
All-non-reserved characters can be used raw, in identifiers.
These are also valid identifiers:: ‘#’ ‘$’ ‘.’
Syntax for primitive data structures:: #true #false #nil str <str> 4.5
Quoted Strings:: "string" “string”
Keys in ‘key→val’ forms must be primitive data structures.
Syntactic forms:: (syntax bar a→b)
Table literals:: {slot1 bar a→b}
Function calls:: [function bar zaz a→b] (this passes {bar zaz a→b} to foo)
Method calls:: [obj:method arg] (def meth :method) [:method obj arg]
Table lookups:: a.b [. a "b"] (def getb .b) [.b a]
Foreign Statements:: $(require io)
Reference a global variable:: $window
Call a foreign method:: $[obj:method a b c]
Call a foreign function:: $[fn a b c]
Javascript example:: $[$document:write "Hello World!"]

Primitive lisp forms:
	(λ name exp)
	(match exp (pattern exp) ...)
	(do exp ...)

Patterns are just data-literals mixed with symbols::
	(match {1 {2} 3} ({1 b c} {b c}))
		This yields: {{2} 3}

## Supported Operations
. lookup :: {table t} → t         -- Table lookup
! mut    :: {table t t} → t       -- Table mutation
apply    :: {func t} → t          -- Call function explicitly.
keys     :: {table} → table       -- Table keys
# len    :: {table} → num         -- Array length
append   :: {table table} → table -- Array concatenation
not      :: {bool} → bool
~        :: {num} → num           -- num * ~1
+        :: {num num} → num
-        :: {num num} → num
* ·      :: {num num} → num
/ ÷      :: {num num} → num
% mod    :: {num num} → num
^ pow    :: {num num} → num
= eq     :: {t t} → bool          -- Equality
~= neq   :: {num num} → bool
<= ≤     :: {num num} → bool
>= ≥     :: {num num} → bool
<        :: {num num} → bool
>        :: {num num} → bool
..       :: {str str} → str       -- Concatenation.
nil?     :: {t} → bool
bool?    :: {t} → bool
func?    :: {t} → bool
str?     :: {t} → bool
num?     :: {t} → bool
foreign? :: {t} → bool
table?   :: {t} → bool

## Example Code
(do
	(match {1 2 k→c} ({a b k→c} (do
		[write a b c])
	(match {1 2 k→3} (e (do
		[write e])))
	(match (λx (match x ({a b k→c} [write a b c])))
		(hello [hello 1 2 k→3]))
	(match {
		(λ pair pair)
		(λ pair (match pair ({car cdr} car)))
		(λ pair (match pair ({car cdr} car)))}
		({cons car cdr} [= [car [cons car cdr]]])))))

S-expression syntax:
	(1 2 3 a=4 b=5)
	Keys must be primitive data structures.
	Quoting is ignored for keys.
		(''''a=b) means (a=b)
	Table constructor syntax:
		{a=b c=d} means `(a=,b c=,d)
	Strings are the same things as quoted symbols.
		(== 'hi “hi”)

Functions:
	All functions take a single, array argument.
	All functions return a single value.
	Use ffi functions to access language specific features.
		These functions are "lua", "py", and "js".
		For example,
			“(lua fn args)” will return an array since lua functions
				can return multiple values.
			In “(py fn args)”, args may include named values
				since python supports keyword arguments.

There is non statement/expression separation.
	Every "block" expression returns the value returned by the last
		expression that it contains.

Built-in functions:
	(write e): prints primitive data using s-expression syntax.
	(read e): parses primitive data using s-expression syntax.
	#lua[%1+%2] construct functions using lua syntax literals.

Lisp forms:
	(exp exp ...)
	(let (a=(read) b=(read)) (write a b))
	(let (a=(read) b=(read)) (write a b))
	(match ((pattern ...) exp) body ...)
	(define var exp)
	(define (fn pattern ...) body ...)
	(quote exp)
	(if exp ifexp elseexp)
	(if exp then=exp else=exp)
	(lambda (pattern ...) body ...)
	(lambda name body ...)
	(and exp ...)
	(or exp ...)
	(begin exp ...)

Pattern-matching examples:
	(match ((a b k=c) {1 2 k=3}) (write a b c))
	(match (e {1 2 k=3}) (write e))
	(define (hello a b k=c) (write a b c))
	(hello 1 2 k=3)
